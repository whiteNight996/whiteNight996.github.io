<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell-重定向]]></title>
    <url>%2F2019%2F08%2F02%2FShell-%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[Shell输入输出重定向解析： 1nohup ./hiveserver2 &gt; /opt/module/hive/logs/server.log 2&gt;&amp;1 &amp; nohub和&amp;区别信号，是Unix系统中进程间通信的一种异步通信机制。 （1）SIGINT信号 （2）SIGHUB信号 Ctrl + C 产生SIGINT信号，关闭shell产生SIGHUB信号 &amp;：命令后面加一个“&amp;”，表示后台运行 &amp;只对SIGINT信号免疫，对SIGHUB信号不免疫 也就是说，&amp;在你使用Ctrl + C 关闭时，进程依然存活；但如果你把shell窗口关闭，进程就会被杀死。 nohub：忽略SIGHUB信号 单独使用nohub时，关闭窗口不会影响进程，但是Ctrl +C 操作会使得进程停止（对SIGHUB免疫，但是对SIGINT不免疫）。 总结要想使进程不受shell窗口关闭 和 Ctrl + C操作的影响，可以将nohup和&amp;指令一起使用。 1nohub ./xxx脚本 ... &amp; 重定向列表 命令 说明 command &gt; file 将输出重定向到 file command &lt; file 将输入重定向到 file command &gt;&gt; file 将输出以追加的方式重定向到 file n &gt; file 将文件描述符为 n 的文件重定向到 file n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file n &gt;&amp; m 将输出文件 m 和 n 合并 n &lt;&amp; m 将输入文件 m 和 n 合并 重定向深入理解一般情况下，每个Unix和Linux命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 如果希望 stderr 重定向到 file，可以这样写： 1$ command 2 &gt; file 2 表示标准错误文件(stderr)。 如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： 12345$ command &gt; file 2&gt;&amp;1或者$ command &gt;&gt; file 2&gt;&amp;1 Linux xargs命令xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 1somecommand |xargs -选项 command xargs 结合 find 使用 用 rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用 xargs 去避免这个问题： 1find . -type f -name "*.log" -print0 | xargs -0 rm -f]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK1.8源码-ArrayList]]></title>
    <url>%2F2019%2F08%2F01%2FJDK1.8%E6%BA%90%E7%A0%81-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList 源码解析（1）JDK1.8：new ArrayList()：发现内部初始化为了一个长度为0的空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA ​ JDK1.7版本：也是初始化为长度为0的空数组 EMPTY_ELEMENTDATA; ​ JDK1.6版本：初始化为长度为10的数组 为什么要初始化为空数组呢？ 因为开发中，很多时候创建了ArrayList的对象，但是没有装元素，这个时候的话，如果初始化为10的数组，就浪费空间了。 （2）什么时候扩容？– add(Object e） JDK1.8：第一次添加元素，扩容为长度为10的数组；如果不够了，再扩容为1.5倍 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//初始化为空数组&#125;public boolean add(E e) &#123; //查看当前数组是否够多存一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! //存入新元素到[size]位置，然后size自增1 elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //如果当前数组还是空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //查看是否需要扩容 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//修改次数加1 // 如果需要的最小容量 比 当前数组的长度 大，即当前数组不够存，就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length;//当前数组容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//新数组容量是旧数组容量的1.5倍 //看旧数组的1.5倍是否够 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //看旧数组的1.5倍是否超过最大数组限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制一个新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125; 1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index);//检验index是否合法 modCount++;//修改次数加1 //取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素 E oldValue = elementData(index); //需要移动的元素个数 int numMoved = size - index - 1; //如果需要移动元素，就用System.arraycopy移动元素 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将elementData[size-1]位置置空，让GC回收空间，元素个数减少 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 12345678910111213 public E set(int index, E element) &#123; rangeCheck(index);//检验index是否合法 //取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素 E oldValue = elementData(index); //用element替换[index]位置的元素 elementData[index] = element; return oldValue;&#125;public E get(int index) &#123; rangeCheck(index);//检验index是否合法 return elementData(index);//返回[index]位置的元素&#125; 12345678910111213141516171819202122232425262728public int indexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从前往后找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从后往前找 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Java内功心法</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
